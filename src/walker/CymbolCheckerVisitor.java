package walker;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.LinkedHashMap;

import autogenerated.CymbolBaseVisitor;
import autogenerated.CymbolParser;



public class CymbolCheckerVisitor extends CymbolBaseVisitor<Type> {
	public Map<String, Type> symbolTable = new HashMap<String,Type>( ); 
	
	class FunctionInfo {
		public String var_name;
		public String label;
		public void setVarName(int n) {
			this.var_name = "n" + (n+1);
		}
		public void setLabel(String name, String returnType, List<String> paramsType) {
			if(paramsType.size() == 0) {
				this.label = "[label=\"" + returnType + " " + name + "( )\"]";
			}
			else {
				this.label = "[label=\"" + returnType + " " + name + '(' + String.join(", ", paramsType) + ")\"]";
			}
		}
		
		public String fileFormat() {
			return (this.var_name + " " + this.label);
		}
	}
	
	private LinkedHashMap<String, FunctionInfo> Functions = new LinkedHashMap<String, FunctionInfo>();
	private LinkedHashMap<String, List<String>> Calls = new LinkedHashMap<String, List<String>>();
	private String func_atual;
	
	private String TextGenerator() {
		String text = "digraph CallGraph {\n";
		for(String k : Functions.keySet()) {
			text += "\t" + Functions.get(k).fileFormat() + ";\n";
		}
		
		for(String k : Calls.keySet()) {
			List<String> aux = Calls.get(k);
			for(String s : aux) {
				text += "\t" + Functions.get(k).var_name + " -> " + Functions.get(s).var_name + ";\n";
			}
		}
		text += "}";
		return text;
	}
	
	private void FileGenerator(String text) {
		File file = new File("output.gv");

		try {
			if(!file.createNewFile()){
				System.out.println("warning: output.gv file already exists!");
			}
			FileWriter writer = new FileWriter(file);
			writer.write(text);
			writer.close();
		}catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	private void PngGenerator(String input){
		String[] args = new String[] {"dot", "-Tpng", input, "-o", "output.png"};
		try{
			ProcessBuilder pb = new ProcessBuilder(args);
			pb.redirectErrorStream(true);

			Process proc = pb.start();

			String line;
			BufferedReader in = new BufferedReader(new InputStreamReader(
			        proc.getInputStream()));
			while ((line = in.readLine()) != null) {
			    System.out.println(line);
			}

			proc.destroy();

		}catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	@Override
	public Type visitFile(CymbolParser.FileContext ctx) {
		Type r = visitChildren(ctx);
		String text = TextGenerator();
		FileGenerator(text);
		PngGenerator("output.gv");
		return r;
	}
	
	@Override
	public Type visitFuncDecl(CymbolParser.FuncDeclContext ctx) {
		String name = ctx.ID().getText();
		String returnType = ctx.type().getText();
		func_atual = name;
		
		//Cria uma lista com os tipos dos argumentos da função
		CymbolParser.ParamTypeListContext params = ctx.paramTypeList();
		List<String> paramsTypes_str = new ArrayList<String>();
		if(params != null) {
			List<CymbolParser.ParamTypeContext> paramTypes = params.paramType();
			for(CymbolParser.ParamTypeContext t : paramTypes) {
				paramsTypes_str.add(t.type().getText());
			}
		}
		
		FunctionInfo func = new FunctionInfo();
		func.setVarName(Functions.size());
		func.setLabel(name, returnType, paramsTypes_str);
		Functions.put(name, func);

		return visitChildren(ctx);
	}
	
	@Override
	public Type visitFunctionCallExpr(CymbolParser.FunctionCallExprContext ctx) {
		String name_func_called = ctx.ID().getText();
		List<String> child_calls;
		if(Calls.containsKey(func_atual)) {
			child_calls = Calls.get(func_atual);
			if(!child_calls.contains(name_func_called)) {
				child_calls.add(name_func_called);
			}
		}
		else {
			Calls.put(func_atual, child_calls = new ArrayList<String>());
			child_calls.add(name_func_called);
		}
		return visitChildren(ctx);
	}
}